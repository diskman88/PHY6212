#ifndef __TRCUSER_H__
#define __TRCUSER_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "trcKernelPort.h"

#if (USE_TRACEALYZER_RECORDER == 1)

#ifndef USE_SEPARATE_USER_EVENT_BUFFER
#define USE_SEPARATE_USER_EVENT_BUFFER 0
#endif

/*******************************************************************************
 * TRACE_STOP_HOOK - Hook Pointer Data Type
 *
 * Declares a data type for a call back function that will be invoked whenever
 * the recorder is stopped.
 ******************************************************************************/
typedef void (*TRACE_STOP_HOOK)(void);

/*******************************************************************************
 * trace_stopHookPtr
 *
 * Points to a call back function that is called from trace_stop().
 ******************************************************************************/
extern TRACE_STOP_HOOK trace_stopHookPtr;

/*******************************************************************************
 * trace_init_data
 *
 * Allocates, if necessary, and initializes the recorder data structure, based
 * on the constants in trcConfig.h.
 ******************************************************************************/
void trace_init_data(void);

/*******************************************************************************
 * trace_set_recorder_data
 *
 * If custom allocation is used, this function must be called so the recorder
 * library knows where to save the trace data.
 ******************************************************************************/
#if (TRACE_DATA_ALLOCATION == TRACE_DATA_ALLOCATION_CUSTOM)
void trace_set_recorder_data(void* pRecorderData);
#endif

/*******************************************************************************
 * trace_set_stop_hook
 *
 * Sets a function to be called when the recorder is stopped.
 ******************************************************************************/
void trace_set_stop_hook(TRACE_STOP_HOOK stopHookFunction);

/*******************************************************************************
 * tarce_start_internal
 *
 * Starts the recorder. The recorder will not be started if an error has been
 * indicated using trace_error, e.g. if any of the Nx constants in trcConfig.h
 * has a too small value (NTASK, NQUEUE, etc).
 *
 * Returns 1 if the recorder was started successfully.
 * Returns 0 if the recorder start was prevented due to a previous internal
 * error. In that case, check vTraceGetLastError to get the error message.
 * Any error message is also presented when opening a trace file.
 *
 ******************************************************************************/
uint32_t tarce_start_internal(void);

/*******************************************************************************
 * trace_start
 *
 * Starts the recorder. The recorder will not be started if an error has been
 * indicated using trace_error, e.g. if any of the Nx constants in trcConfig.h
 * has a too small value (NTASK, NQUEUE, etc).
 *
 * This function is obsolete, but has been saved for backwards compatibility.
 * We recommend using tarce_start_internal instead.
 ******************************************************************************/
void trace_start(void);

/*******************************************************************************
 * trace_stop
 *
 * Stops the recorder. The recording can be resumed by calling trace_start.
 * This does not reset the recorder. Use trace_clear is that is desired.
 ******************************************************************************/
void trace_stop(void);

/*******************************************************************************
 * trace_get_last_error
 *
 * Gives the last error message, if any. NULL if no error message is stored.
 * Any error message is also presented when opening a trace file.
 ******************************************************************************/
char* trace_get_last_error(void);

/*******************************************************************************
 * trace_clear
 *
 * Resets the recorder. Only necessary if a restart is desired - this is not
 * needed in the startup initialization.
 ******************************************************************************/
void trace_clear(void);

/*******************************************************************************
* trace_clear_error
*
* Removes any previous error message generated by recorder calling trace_error.
* By calling this function, it may be possible to start/restart the trace
* despite errors in the recorder, but there is no guarantee that the trace
* recorder will work correctly in that case, depending on the type of error.
******************************************************************************/
void trace_clear_error(int resetErrorMessage);

#if (INCLUDE_ISR_TRACING == 1)

/*******************************************************************************
 * trace_set_isr_properties
 *
 * Registers an Interrupt Service Routine in the recorder library, This must be
 * called before using trace_store_isr_begin to store ISR events. This is
 * typically called in the startup of the system, before the scheduler is
 * started.
 *
 * Example:
 *	 #define ID_ISR_TIMER1 1		// lowest valid ID is 1
 *	 #define PRIO_OF_ISR_TIMER1 3 // the hardware priority of the interrupt
 *	 ...
 *	 trace_set_isr_properties(ID_ISR_TIMER1, "ISRTimer1", PRIO_OF_ISR_TIMER1);
 *	 ...
 *	 void ISR_handler()
 *	 {
 *		 trace_store_isr_begin(ID_OF_ISR_TIMER1);
 *		 ...
 *		 trace_store_isr_end(0);
 *	 }
 ******************************************************************************/
void trace_set_isr_properties(object_handle_t handle, const char* name, char priority);

/*******************************************************************************
 * trace_store_isr_begin
 *
 * Registers the beginning of an Interrupt Service Routine.
 * If allowing nested ISRs, this must be called with interrupts disabled.
 *
 * Example:
 *	 #define ID_ISR_TIMER1 1		// lowest valid ID is 1
 *	 #define PRIO_OF_ISR_TIMER1 3 // the hardware priority of the interrupt
 *	 ...
 *	 trace_set_isr_properties(ID_ISR_TIMER1, "ISRTimer1", PRIO_OF_ISR_TIMER1);
 *	 ...
 *	 void ISR_handler()
 *	 {
 *		 trace_store_isr_begin(ID_OF_ISR_TIMER1);
 *		 ...
 *		 trace_store_isr_end(0);
 *	 }
 *
 ******************************************************************************/
void trace_store_isr_begin(object_handle_t id);

/*******************************************************************************
 * trace_store_isr_end
 *
 * Registers the end of an Interrupt Service Routine.
 *
 * The parameter pendingISR indicates if the interrupt has requested a
 * task-switch (= 1) or if the interrupt returns to the earlier context (= 0)
 *
 * Example:
 *	 #define ID_ISR_TIMER1 1	  // lowest valid ID is 1
 *	 #define PRIO_OF_ISR_TIMER1 3 // the hardware priority of the interrupt
 *	 ...
 *	 trace_set_isr_properties(ID_ISR_TIMER1, "ISRTimer1", PRIO_OF_ISR_TIMER1);
 *	 ...
 *	 void ISR_handler()
 *	 {
 *		 trace_store_isr_begin(ID_OF_ISR_TIMER1);
 *		 ...
 *		 trace_store_isr_end(0);
 *	 }
 *
 ******************************************************************************/
void trace_store_isr_end(int pendingISR);

#else
	/* If not including the ISR recording */

void trace_increase_isr_active(void);

void trace_decrease_isr_active(void);

#define trace_set_isr_properties(handle, name, priority)
#define trace_store_isr_begin(id) trace_increase_isr_active()
#define trace_store_isr_end() trace_decrease_isr_active()

#endif


/******************************************************************************
 * trace_task_instance_finish(void)
 *
 * Marks the current task instance as finished on the next kernel call.
 *
 * If that kernel call is blocking, the instance ends after the blocking event
 * and the corresponding return event is then the start of the next instance.
 * If the kernel call is not blocking, the viewer instead splits the current
 * fragment right before the kernel call, which makes this call the first event
 * of the next instance.
 *
 * See also USE_IMPLICIT_IFE_RULES in trcConfig.h
 *
 * Example:
 *
 *		while(1)
 *		{
 *			xQueueReceive(CommandQueue, &command, timeoutDuration);
 *			processCommand(command);
 *          vTraceInstanceFinish();
 *		}
 *
 *****************************************************************************/
void trace_task_instance_finish(void);

/******************************************************************************
 * trace_task_instance_finish_direct(void)
 *
 * Marks the current task instance as finished at this very instant.
 * This makes the viewer to splits the current fragment at this point and begin
 * a new actor instance.
 *
 * See also USE_IMPLICIT_IFE_RULES in trcConfig.h
 *
 * Example:
 *
 *		This example will generate two instances for each loop iteration.
 *		The first instance ends at trace_task_instance_finish_direct(), while the second
 *      instance ends at the next xQueueReceive call.
 *
 *		while (1)
 *		{
 *          xQueueReceive(CommandQueue, &command, timeoutDuration);
 *			ProcessCommand(command);
 *			trace_task_instance_finish_direct();
 *			DoSometingElse();
 *          vTraceInstanceFinish();
 *      }
 *
 *
 *****************************************************************************/
void trace_task_instance_finish_direct(void);

/*******************************************************************************
 * trace_get_trace_buffer
 *
 * Returns a pointer to the recorder data structure. Use this together with
 * trace_get_trace_buffer_size if you wish to implement an own store/upload
 * solution, e.g., in case a debugger connection is not available for uploading
 * the data.
 ******************************************************************************/
void* trace_get_trace_buffer(void);

/*******************************************************************************
 * trace_get_trace_buffer_size
 *
 * Gets the size of the recorder data structure. For use together with
 * trace_get_trace_buffer if you wish to implement an own store/upload solution,
 * e.g., in case a debugger connection is not available for uploading the data.
 ******************************************************************************/
uint32_t trace_get_trace_buffer_size(void);

#if (INCLUDE_USER_EVENTS == 1)

/*******************************************************************************
 * trace_open_label
 *
 * Creates user event labels for user event channels or for individual events.
 * User events can be used to log application events and data for display in
 * the visualization tool. A user event is identified by a label, i.e., a string,
 * which is stored in the recorder's symbol table.
 * When logging a user event, a numeric handle (reference) to this string is
 * used to identify the event. This is obtained by calling
 *
 *	 trace_open_label()
 *
 * whihc adds the string to the symbol table (if not already present)
 * and returns the corresponding handle.
 *
 * This can be used in two ways:
 *
 * 1. The handle is looked up every time, when storing the user event.
 *
 * Example:
 *	 trace_user_event(trace_open_label("MyUserEvent"));
 *
 * 2. The label is registered just once, with the handle stored in an
 * application variable - much like using a file handle.
 *
 * Example:
 *	 myEventHandle = trace_open_label("MyUserEvent");
 *	 ...
 *	 trace_user_event(myEventHandle);
 *
 * The second option is faster since no lookup is required on each event, and
 * therefore recommended for user events that are frequently
 * executed and/or located in time-critical code. The lookup operation is
 * however fairly fast due to the design of the symbol table.
 ******************************************************************************/
traceLabel trace_open_label(const char* label);

 /******************************************************************************
 * trace_user_event
 *
 * Basic user event (Standard and Professional Edition only)
 *
 * Generates a User Event with a text label. The label is created/looked up
 * in the symbol table using trace_open_label.
 ******************************************************************************/
void trace_user_event(traceLabel eventLabel);

 /******************************************************************************
 * trace_printf
 *
 * Advanced user events (Professional Edition only)
 *
 * Generates User Event with formatted text and data, similar to a "printf".
 * It is very fast compared to a normal "printf" since this function only
 * stores the arguments. The actual formatting is done
 * on the host PC when the trace is displayed in the viewer tool.
 *
 * User Event labels are created using trace_open_label.
 * Example:
 *
 *	 traceLabel adc_uechannel = trace_open_label("ADC User Events");
 *	 ...
 *	 vTracePrint(adc_uechannel,
 *				 "ADC channel %d: %lf volts",
 *				 ch, (double)adc_reading/(double)scale);
 *
 * This can be combined into one line, if desired, but this is slower:
 *
 *	 vTracePrint(trace_open_label("ADC User Events"),
 *				 "ADC channel %d: %lf volts",
 *				 ch, (double)adc_reading/(double)scale);
 *
 * Calling trace_open_label multiple times will not create duplicate entries, but
 * it is of course faster to just do it once, and then keep the handle for later
 * use. If you donï¿½t have any data arguments, only a text label/string, it is
 * better to use trace_user_event - it is faster.
 *
 * Format specifiers supported:
 * %d - 32 bit signed integer
 * %u - 32 bit unsigned integer
 * %f - 32 bit float
 * %s - string (is copied to the recorder symbol table)
 * %hd - 16 bit signed integer
 * %hu - 16 bit unsigned integer
 * %bd - 8 bit signed integer
 * %bu - 8 bit unsigned integer
 * %lf - double-precision float (Note! See below...)
 *
 * Up to 15 data arguments are allowed, with a total size of maximum 32 byte.
 * In case this is exceeded, the user event is changed into an error message.
 *
 * The data is stored in trace buffer, and is packed to allow storing multiple
 * smaller data entries in the same 4-byte record, e.g., four 8-bit values.
 * A string requires two bytes, as the symbol table is limited to 64K. Storing
 * a double (%lf) uses two records, so this is quite costly. Use float (%f)
 * unless the higher precision is really necessary.
 *
 * Note that the double-precision float (%lf) assumes a 64 bit double
 * representation. This does not seem to be the case on e.g. PIC24 and PIC32.
 * Before using a %lf argument on a 16-bit MCU, please verify that
 * "sizeof(double)" actually gives 8 as expected. If not, use %f instead.
 ******************************************************************************/
void trace_printf(traceLabel eventLabel, const char* formatStr, ...);

#if (USE_SEPARATE_USER_EVENT_BUFFER == 1)
UserEventChannel trace_register_channel_format(traceLabel channel, traceLabel formatStr);
void trace_channel_printf(UserEventChannel channel, ...);
void trace_channel_user_event(UserEventChannel channel);
#endif

#else

#define trace_printf(eventLabel, formatStr, ...);
#define trace_open_label(label) 0
#define trace_user_event(eventLabel)

#endif

#else

/* Empty defines for user functions to avoid compiler errors if trace is not to be used */

#define trace_init_data()
#define tarce_start_internal() (1) // Fake "success", if used when recorder is excluded from build
#define trace_start()
#define trace_stop()
#define trace_clear()
#define vTraceStartStatusMonitor()
#define trace_get_trace_buffer() ((void*)0)
#define trace_get_trace_buffer_size() 0
#define trace_open_label(label) 0
#define trace_user_event(eventLabel)
#define trace_printf(eventLabel,formatStr,...)

#define trace_set_isr_properties(handle, name, priority)
#define trace_store_isr_begin(id)
#define trace_store_isr_end(flag)
#define trace_set_stop_hook(a)

#define TRACE_SET_QUEUE_NAME(a, b)
#define TRACE_SET_MUTEX_NAME(a, b)
#define TRACE_SET_SEMAPHORE_NAME(a, b)
#define TRACE_SET_EVENTGROUP_NAME(a, b)

#endif

#ifdef __cplusplus
}
#endif

#endif
